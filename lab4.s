;=====================================================================
;  Лабораторная работа № 4 — Вариант 35 (NASM x86‑64, Linux, без PIE)
;=====================================================================
;  ЗАДАНИЕ
;  ───────────────────────────────────────────────────────────────────
;  • Считать с клавиатуры два числа одинарной точности (float):
;        x  – аргумент функции
;        ε  – требуемая точность (абсолютное значение очередного члена < ε)
;  • Вычислить cos²(x) двумя способами:
;        1) через библиотечную функцию cosf()   (проверка)
;        2) через ряд Тейлора
;              cos²(x) = 1 + Σ_{n=1..∞} (-1)^n · (2^{2n‑1} / (2n)!) · x^{2n}
;  • Вывести оба результата и количество использованных членов ряда.
;  • Каждый член ряда записывать в текстовый файл, имя которого
;    передаётся единственным аргументом командной строки.
;  • Окружение: Linux x86‑64, System V ABI, одинарная точность (float).
;  • Работать «по‑бедному»: только функции libc/libm, без системных вызовов.
;
;  СБОРКА
;  ───────────────────────────────────────────────────────────────────
;  nasm -felf64 lab4.asm
;  gcc  -no-pie -o lab4 lab4.o -lm        ; -no-pie  →  позиционно‑зависимый код
;
;  ЗАПУСК
;  ./lab4 terms.txt   →  далее ввести:  x  ε    (через пробел)
;=====================================================================

; --------------------------------------------------------------------
;  ТЕОРИЯ: рекуррентная формула для членов ряда
; --------------------------------------------------------------------
;  Базовый член (n = 1):
;       term₁ = -x²                                  (т.к. 2^{1}=2, 2!/2 =1)
;
;  Общий член:     term_n = (-1)^n · 2^{2n‑1} · x^{2n} / (2n)!
;
;  Переход к следующему члену:
;      term_{n+1} = term_n · [ (-4 · x²) / ( (2n+2)(2n+1) ) ]
;  ───────────────────────────────────────────────────────────────────
;  • множитель -4·x²  в числителе ⇒ знак автоматически чередуется
;  • делитель (2n+2)(2n+1)         ⇒ факториальная часть без переполнения
; --------------------------------------------------------------------

                bits 64

; ===============  СЕКЦИЯ ДАННЫХ  ====================================
section .data
str_usage       db  "Использование: ./lab4 <имя_файла>",10,0
str_fopen_err   db  "Не удалось открыть файл.",10,0

fmt_scanf       db  "%f %f",0                     ; ввод x ε
fmt_term        db  "%d\t%f\n",0                  ; запись члена ряда: n  term
fmt_result      db  "cos^2(x) (libm): %f\n"
                db  "cos^2(x) (ряд) : %f\n"
                db  "Членов учтено : %d\n",0

file_mode       db  "w",0                         ; режим "write"

one_float       dd  1.0
minus_four      dd  -4.0                           ; для множителя -4·x²
abs_mask        dd  0x7FFFFFFF                    ; маска для |float|

; ===============  СЕКЦИЯ BSS (неиниц. данные)  ======================
section .bss
input_x             resd 1   ; введённый x
input_eps           resd 1   ; введённая ε
series_sum          resd 1   ; текущая сумма ряда
current_term        resd 1   ; очередной член ряда
terms_used          resd 1   ; счётчик n
file_ptr            resq 1   ; FILE*
libm_result         resd 1   ; cos²(x) через cosf

; ===============  ПРОТОТИПЫ ВНЕШНИХ ФУНКЦИЙ  =======================
section .text
    extern  printf, scanf, fopen, fprintf, fclose, cosf, exit
    global  main

; ===================================================================
;                           ФУНКЦИЯ  main
; ===================================================================
main:
    ;----------------------------------------------------------
    ; Пролог (ABI System V)
    ;  • сохраняем RBP
    ;  • тем самым выравниваем стек (RSP mod 16 = 0)
    ;  Важно!  Без этого первый вызов printf рушился из‑за
    ;  неверного выравнивания стека → segmentation fault.
    ;----------------------------------------------------------
    push rbp
    mov  rbp, rsp
    ;----------------------------------------------------------------
    ; 1. Проверяем наличие аргумента с именем файла
    ;----------------------------------------------------------------
    cmp rdi, 2                          ; argc должно быть 2
    je  open_file

    ; Сообщаем об ошибке использования и завершаем программу
    lea rdi, [str_usage]
    xor eax, eax
    call printf
    mov edi, 1
    call exit

;--------------------------------------------------------------------
; 2. Открываем файл для записи членов ряда
;--------------------------------------------------------------------
open_file:
    ; argv находится в rsi — берём argv[1]
    mov  rdi, [rsi + 8]                 ; 1‑й аргумент → rdi
    lea  rsi, [file_mode]               ; "w"
    call fopen                          ; FILE* → rax
    test rax, rax
    jnz  file_open_ok

    ; Если fopen вернул NULL
    lea rdi, [str_fopen_err]
    xor eax, eax
    call printf
    mov edi, 1
    call exit

file_open_ok:
    mov [file_ptr], rax                 ; сохраняем FILE*

;--------------------------------------------------------------------
; 3. Читаем x и ε
;--------------------------------------------------------------------
    lea rdi, [fmt_scanf]
    lea rsi, [input_x]
    lea rdx, [input_eps]
    xor eax, eax                        ; для varargs с float
    call scanf

;--------------------------------------------------------------------
; 4. Подготавливаем начальные значения ряда
;--------------------------------------------------------------------
    ; term₁ = -x²
    movss xmm0, [input_x]
    mulss xmm0, xmm0                    ; x²
    xorps xmm1, xmm1
    subss xmm1, xmm0                    ; -x²
    movss [current_term], xmm1

    ; sum = 1 + term₁
    movss xmm0, [one_float]
    addss xmm0, xmm1
    movss [series_sum], xmm0

    mov dword [terms_used], 1           ; n = 1 (уже учли term₁)

;--------------------------------------------------------------------
; 5. ЦИКЛ: добавляем члены, пока |term| ≥ ε
;--------------------------------------------------------------------
series_loop:
    ; |term| < ε ?  →  выходим
    movss xmm0, [current_term]
    andps xmm0, [abs_mask]              ; abs(term)
    movss xmm1, [input_eps]
    comiss xmm1, xmm0                   ; ε < |term| ?
    jae  series_done                    ; если |term| < ε, заканчиваем

    ; Записываем текущий член в файл
    mov  rdi, [file_ptr]
    lea  rsi, [fmt_term]
    mov  eax, [terms_used]              ; n
    mov  edx, eax                       ; 3‑й аргумент (int) → rdx
    cvtss2sd xmm0, [current_term]       ; term → double в xmm0
    xor  r8, r8
    xor  r9, r9
    mov  eax, 1                         ; один float/double арг.
    call fprintf

    ; term_{n+1} = term_n * (-4·x²) / ((2n+2)(2n+1))

    ; вычисляем множитель (-4·x²) единожды в xmm3
    ;   (x² уже был в xmm0 ранее, но сейчас проще пересчитать)
    movss xmm0, [input_x]
    mulss xmm0, xmm0                    ; x²
    mulss xmm0, [minus_four]            ; -4·x²  → xmm0

    mov eax, [terms_used]               ; n
    shl eax, 1                          ; 2n
    add eax, 2                          ; 2n + 2
    mov ebx, eax                        ; ebx = 2n + 2
    dec ebx                             ; ebx = 2n + 1
    imul eax, ebx                       ; eax = (2n+2)(2n+1)
    cvtsi2ss xmm1, eax                  ; denom (float) в xmm1

    ; term_n * (-4·x²) / denom
    movss xmm2, [current_term]
    mulss xmm2, xmm0
    divss xmm2, xmm1
    movss [current_term], xmm2          ; сохраняем term_{n+1}

    ; sum += term_{n+1}
    movss xmm3, [series_sum]
    addss xmm3, xmm2
    movss [series_sum], xmm3

    ; n++
    inc dword [terms_used]
    jmp series_loop

;--------------------------------------------------------------------
; 6. Завершаем: вывод результатов и очистка
;--------------------------------------------------------------------
series_done:
    ; cos²(x) через libm
    movss xmm0, [input_x]
    call cosf                           ; cosf(x)
    mulss xmm0, xmm0                    ; cos²(x)
    movss [libm_result], xmm0

    ; Печать результатов
    lea rdi, [fmt_result]
    cvtss2sd xmm0, [libm_result]
    cvtss2sd xmm1, [series_sum]
    mov edx, [terms_used]
    mov eax, 2                          ; два float аргумента
    call printf

    ; Закрываем файл и выходим
    mov rdi, [file_ptr]
    call fclose

    xor eax, eax                        ; return 0
    ret
